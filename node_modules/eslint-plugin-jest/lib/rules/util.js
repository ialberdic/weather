"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.composeFixers = composeFixers;
exports.scopeHasLocalReference = exports.getDocsUrl = exports.getStringValue = exports.hasExpressions = exports.isTemplateLiteral = exports.isString = exports.isFunction = exports.isDescribe = exports.isTestCase = exports.isHook = exports.getNodeName = exports.argument2 = exports.argument = exports.method2 = exports.method = exports.expectNotToEqualCase = exports.expectToEqualCase = exports.expectNotToBeCase = exports.expectToBeCase = exports.expectNotRejectsCase = exports.expectRejectsCase = exports.expectNotResolvesCase = exports.expectResolvesCase = exports.expectNotCase = exports.expectCaseWithParent = exports.expectCase = void 0;

var _path = require("path");

var _package = require("../../package.json");

const REPO_URL = 'https://github.com/jest-community/eslint-plugin-jest';

const expectCase = node => node && node.callee && node.callee.name === 'expect';

exports.expectCase = expectCase;

const expectCaseWithParent = node => expectCase(node) && node.parent && node.parent.type === 'MemberExpression' && node.parent.parent;

exports.expectCaseWithParent = expectCaseWithParent;

const expectNotCase = node => expectCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node) === 'not';

exports.expectNotCase = expectNotCase;

const expectResolvesCase = node => expectCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node) === 'resolves';

exports.expectResolvesCase = expectResolvesCase;

const expectNotResolvesCase = node => expectNotCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node.parent) === 'resolves';

exports.expectNotResolvesCase = expectNotResolvesCase;

const expectRejectsCase = node => expectCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node) === 'rejects';

exports.expectRejectsCase = expectRejectsCase;

const expectNotRejectsCase = node => expectNotCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node.parent) === 'rejects';

exports.expectNotRejectsCase = expectNotRejectsCase;

const expectToBeCase = (node, arg) => !(expectNotCase(node) || expectResolvesCase(node) || expectRejectsCase(node)) && expectCase(node) && methodName(node) === 'toBe' && argument(node) && (argument(node).type === 'Literal' && argument(node).value === null && arg === null || argument(node).name === 'undefined' && arg === undefined);

exports.expectToBeCase = expectToBeCase;

const expectNotToBeCase = (node, arg) => expectNotCase(node) && methodName2(node) === 'toBe' && argument2(node) && (argument2(node).type === 'Literal' && argument2(node).value === null && arg === null || argument2(node).name === 'undefined' && arg === undefined);

exports.expectNotToBeCase = expectNotToBeCase;

const expectToEqualCase = (node, arg) => !(expectNotCase(node) || expectResolvesCase(node) || expectRejectsCase(node)) && expectCase(node) && methodName(node) === 'toEqual' && argument(node) && (argument(node).type === 'Literal' && argument(node).value === null && arg === null || argument(node).name === 'undefined' && arg === undefined);

exports.expectToEqualCase = expectToEqualCase;

const expectNotToEqualCase = (node, arg) => expectNotCase(node) && methodName2(node) === 'toEqual' && argument2(node) && (argument2(node).type === 'Literal' && argument2(node).value === null && arg === null || argument2(node).name === 'undefined' && arg === undefined);

exports.expectNotToEqualCase = expectNotToEqualCase;

const method = node => node.parent.property;

exports.method = method;

const method2 = node => node.parent.parent.property;

exports.method2 = method2;

const methodName = node => method(node).name;

const methodName2 = node => method2(node).name;

const argument = node => node.parent.parent.arguments && node.parent.parent.arguments[0];

exports.argument = argument;

const argument2 = node => node.parent.parent.parent.arguments && node.parent.parent.parent.arguments[0];

exports.argument2 = argument2;
const describeAliases = new Set(['describe', 'fdescribe', 'xdescribe']);
const testCaseNames = new Set(['fit', 'it', 'test', 'xit', 'xtest']);
const testHookNames = new Set(['beforeAll', 'beforeEach', 'afterAll', 'afterEach']);

const getNodeName = node => {
  function joinNames(a, b) {
    return a && b ? `${a}.${b}` : null;
  }

  switch (node && node.type) {
    case 'Identifier':
      return node.name;

    case 'Literal':
      return node.value;

    case 'TemplateLiteral':
      if (node.expressions.length === 0) return node.quasis[0].value.cooked;
      break;

    case 'MemberExpression':
      return joinNames(getNodeName(node.object), getNodeName(node.property));
  }

  return null;
};

exports.getNodeName = getNodeName;

const isHook = node => node && node.type === 'CallExpression' && node.callee.type === 'Identifier' && testHookNames.has(node.callee.name);

exports.isHook = isHook;

const isTestCase = node => node && node.type === 'CallExpression' && (node.callee.type === 'Identifier' && testCaseNames.has(node.callee.name) || node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && testCaseNames.has(node.callee.object.name));

exports.isTestCase = isTestCase;

const isDescribe = node => node && node.type === 'CallExpression' && (node.callee.type === 'Identifier' && describeAliases.has(node.callee.name) || node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && describeAliases.has(node.callee.object.name));

exports.isDescribe = isDescribe;

const isFunction = node => node && (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression');

exports.isFunction = isFunction;

const isString = node => node && (node.type === 'Literal' && typeof node.value === 'string' || isTemplateLiteral(node));

exports.isString = isString;

const isTemplateLiteral = node => node && node.type === 'TemplateLiteral';

exports.isTemplateLiteral = isTemplateLiteral;

const hasExpressions = node => node && node.expressions && node.expressions.length > 0;

exports.hasExpressions = hasExpressions;

const getStringValue = arg => isTemplateLiteral(arg) ? arg.quasis[0].value.raw : arg.value;
/**
 * Generates the URL to documentation for the given rule name. It uses the
 * package version to build the link to a tagged version of the
 * documentation file.
 *
 * @param {string} filename - Name of the eslint rule
 * @returns {string} URL to the documentation for the given rule
 */


exports.getStringValue = getStringValue;

const getDocsUrl = filename => {
  const ruleName = (0, _path.basename)(filename, '.js');
  return `${REPO_URL}/blob/v${_package.version}/docs/rules/${ruleName}.md`;
};

exports.getDocsUrl = getDocsUrl;

const collectReferences = scope => {
  const locals = new Set();
  const unresolved = new Set();
  let currentScope = scope;

  while (currentScope !== null) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = currentScope.variables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const ref = _step.value;
        const isReferenceDefined = ref.defs.some(def => {
          return def.type !== 'ImplicitGlobalVariable';
        });

        if (isReferenceDefined) {
          locals.add(ref.name);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = currentScope.through[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const ref = _step2.value;
        unresolved.add(ref.identifier.name);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    currentScope = currentScope.upper;
  }

  return {
    locals,
    unresolved
  };
};

const scopeHasLocalReference = (scope, referenceName) => {
  const references = collectReferences(scope);
  return (// referenceName was found as a local variable or function declaration.
    references.locals.has(referenceName) || // referenceName was not found as an unresolved reference,
    // meaning it is likely not an implicit global reference.
    !references.unresolved.has(referenceName)
  );
};

exports.scopeHasLocalReference = scopeHasLocalReference;

function composeFixers(node) {
  return (...fixers) => {
    return fixerApi => {
      return fixers.reduce((all, fixer) => [...all, fixer(node, fixerApi)], []);
    };
  };
}